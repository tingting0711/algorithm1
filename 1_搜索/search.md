# 第二章：搜索
## BFS

- 求最小距离
- 基于迭代 -> 不会爆栈
- 可用于求边长为1的最短路
- 第一次遍历到某点时，就是该点距离源点最近时(入队时)
- 需要状态数组st表示是否已经遍历过该点
- 每个点只会入队1次
- 线性时间求短路
- 队列

## DFS

- 基于连通性
  - Flood Fill
  - 树与图的遍历
- 栈
- 是否恢复现场
  - 内部搜索：棋盘内部 （无需）
  - 外部搜索：一个棋盘到另一个棋盘（需要）
- 时间复杂度
  - 一般不分析时间复杂度，比较哲学
  - 内部搜索：线性级别
  - 外部搜索：指数级别



## Flood Fill

可以在线性时间复杂度内找到所有的连通块

- 池塘计数
  
- 城堡问题

- 山峰和山谷


> 池塘计数

```

```

> 城堡问题

```

```

> 山峰和山谷

```

```



## 最短路模型

- 迷宫问题

- 武士风度的牛

- 抓住那头牛

  

> 迷宫问题

```

```

> 武士风度的牛

```

```

> 抓住那头牛

```

```



## 多源BFS

- 到**最近的源点**的最短距离（与多源最短路有差异）
- 通过新加一个虚拟源点，虚拟源点到初始源点集距离都为0（转化为单源最短路径）
- BFS与dijkstra的差异：
  - BFS在节点入队时即可确定最小距离（两段性，单调性）
  - BFS距离可初始化为-1即可，表示尚未被更新/入队
  - BFS节点只会入队一次
- 矩阵距离


> 矩阵距离

```

```



## 最小步数模型

- 魔板


> 魔板

```

```



## 双端队列广搜

- 电路维修


> 电路维修

```

```



## 双向广搜(BFS 优化)

主要用于减少搜索空间；

- 最小步数模型
- 字串变换


> 字串变换

```

```



## A*(BFS 优化)

主要用于减少搜索空间；

将队列换成**优先队列**（小根堆）；

总距离 ： 从起点到当前点的真实距离 + 从当前点到终点的估计距离；

当终点第一次**出队**时结束算法；

如果无解尽量不要使用A*，因为优先队列的操作为logN, 则算法会退化成普通算法（更差）；

只保证**终点**第一次出队时距离最小，**其余点**第一次出队时不保证最小；

总结：

- BFS 每个节点入队一次，入队时判重，入队时即可求得最小距离
- Dijkstra 每个节点入队可能入队多次，出队时判重，出队时可求得最小距离
- A*  只有终点第一次出队时才可求得距离，其余点无规律可言

- 第K短路
- 八数码

> 第K短路

```

```

> 八数码

```

```



## DFS之连通性模型

- 剪枝
  - 优化搜索顺序
    - 优先搜索分支少的方案 
  - 排除等效冗余
    - 组合数与排列数问题
  - 可行性剪枝
  - 最优化剪枝
  - 记忆化搜索（DP）
- 迷宫
- 红与黑

> 迷宫

```

```

> 红与黑

```

```



## DFS之搜索顺序

- 马走日
- 单词接龙
- 分成互质组

> 马走日

```

```

> 单词接龙

```

```

> 单词接龙

```

```



## DFS之剪枝与优化

- 小猫爬山
- 数独
- 木棒
- 生日蛋糕

> 小猫爬山

```

```

> 数独

```

```

> 木棒

```

```

> 生日蛋糕

```

```



## 迭代加深

- 加成序列


> 加成序列

```

```



## 双向DFS

- 空间换时间
- 送礼物


> 送礼物

```

```



## IDA*

- 排书
- 回转游戏

> 排书

```

```

> 回转游戏

```

```